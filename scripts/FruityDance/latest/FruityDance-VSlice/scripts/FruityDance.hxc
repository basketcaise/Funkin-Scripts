import funkin.modding.module.Module;
import funkin.modding.events.ScriptEvent;
import funkin.ui.transition.StickerSubState;
import funkin.play.PlayState;
import funkin.Paths;

import Std;
import flixel.FlxG;
import flixel.FlxSprite;
import flixel.FlxCamera;
import flixel.tweens.FlxTween;

import flixel.util.FlxSave;
import flixel.util.FlxTimer;

import flixel.text.FlxText;
import flixel.text.FlxTextBorderStyle;

import flixel.math.FlxBasePoint;
import flixel.graphics.frames.FlxTileFrames;

class FruityDance extends Module {
	var fruitySave:FlxSave;
	
	public function new() {
		super('Fruity Dance (V-Slice)');
		fruitySave = new FlxSave();
		fruitySave.bind('FruityDance-VSlice', 'Basketcaise');
		
		if (fruitySave.data.curDance == null) {
			fruitySave.data.dancerX = 0;
			fruitySave.data.dancerY = 0;
			fruitySave.data.curDance = 0;
			
			fruitySave.flush();
		}
	}
	
	var fruityDancer:FlxSprite;
	var fruityDances:Array<String> = ['waiting', 'stepping', 'jumping', 'zombie', 'waving', 'hula', 'windmill', 'zitabata', 'dervish'];
	var holdingDancer:Bool = false;
	
	var fruityTimer:FlxTimer;
	var fruityText:FlxText;
	var fruityStep:Int; // no idea how to use CountdownStep so using this for now!
	
	function onSongLoaded(event) {
		super.onSongLoaded(event);
		var state = PlayState.instance;
		
		fruityDancer = new FlxSprite(fruitySave.data.dancerX, fruitySave.data.dancerY);
		var fruityGraphic = FlxG.bitmap.add(Paths.image('fruityDancer'), false);
		fruityDancer.frames = FlxTileFrames.fromGraphic(fruityGraphic, FlxBasePoint.get(220, 256));
		fruityDancer.cameras = [state.camHUD];
		state.add(fruityDancer);
		
		fruityTimer = new FlxTimer();
		
		fruityText = new FlxText(fruityDancer.getGraphicMidpoint().x - 640, fruityDancer.getGraphicMidpoint().y - 125, FlxG.width, 'Fruity Dance!');
		fruityText.setFormat(Paths.font('vcr.ttf'), 20, 0xFFFFFFFF, 'center', FlxTextBorderStyle.OUTLINE, 0xFF000000);
		fruityText.borderSize = 1.25;
		fruityText.cameras = [state.camHUD];
		fruityText.alpha = 0;
		state.add(fruityText);
		
		fruityDancer.animation.add('held', [0 + (8 * (fruityDances.length)), 1 + (8 * (fruityDances.length)), 2 + (8 * (fruityDances.length)), 3 + (8 * (fruityDances.length)), 4 + (8 * (fruityDances.length )), 5 + (8 * (fruityDances.length)), 6 + (8 * (fruityDances.length)), 7 + (8 * (fruityDances.length))], 8, true);
		
		for (i in 0...fruityDances.length) {
			fruityDancer.animation.add(fruityDances[i] + 'Left', [0 + (8 * i), 1 + (8 * i), 2 + (8 * i), 3 + (8 * i)], 8, false);
			fruityDancer.animation.add(fruityDances[i] + 'Right', [4 + (8 * i), 5 + (8 * i), 6 + (8 * i), 7 + (8 * i)], 8, false);
		}
		
		FlxG.mouse.visible = true;
	}

	function onUpdate(elapsed:Float) {
		super.onUpdate(elapsed);
		var state = PlayState.instance;
		if (state == null) return;
		
		if (fruityDancer != null) {
			if (FlxG.mouse.overlaps(fruityDancer, state.camHUD) && FlxG.mouse.pressed && (FlxG.mouse.deltaScreenX != 0 || FlxG.mouse.deltaScreenY != 0)) {
				holdingDancer = true;
				fruityDancer.animation.play('held', false);
				
				fruityDancer.x += FlxG.mouse.deltaScreenX * FlxG.camera.zoom;
				fruityDancer.y += FlxG.mouse.deltaScreenY * FlxG.camera.zoom;
				
				fruityText.x += FlxG.mouse.deltaScreenX * FlxG.camera.zoom;
				fruityText.y += FlxG.mouse.deltaScreenY * FlxG.camera.zoom;
			} else if (holdingDancer) {
				holdingDancer = false;
				
				fruitySave.data.dancerX = fruityDancer.x;
				fruitySave.data.dancerY = fruityDancer.y;
				
				fruitySave.flush();
			}
			
			if (state.needsReset) {
				fruityDancer.destroy();
				fruityText.destroy();
			}
		}
		
		if (FlxG.keys.justPressed.SPACE) {
			if (fruitySave.data.curDance >= fruityDances.length - 1)
				fruitySave.data.curDance = 0;
			else
				fruitySave.data.curDance += 1;
			
			fruitySave.flush();
			
			fruityTimer.cancel();
			FlxTween.completeTweensOf(fruityText);
			FlxTween.completeTweensOf(fruityText.offset);
			FlxTween.globalManager.update(0);
			
			fruityText.text = fruityDances[fruitySave.data.curDance];
			fruityText.alpha = 1;
			
			fruityTimer.start(1, () -> {
				FlxTween.tween(fruityText, {alpha: 0}, 1, {onComplete: function() { fruityText.text = 'Fruity Dance!'; } });
				FlxTween.tween(fruityText.offset, {y: 25}, 1, {onComplete: function() { fruityText.offset.y = 0; } });
			});
		}
	}
	
	function onCountdownStart(event) {
		super.onCountdownStart(event);
		fruityStep = 4;
	}
	
	function onCountdownStep(event) {
		super.onCountdownStep(event);
		fruityStep -= 1;
		
		if (!holdingDancer) {
			if (fruityStep % 2 == 1)
				fruityDancer.animation.play(fruityDances[fruitySave.data.curDance] + 'Left', false);
			else if (fruityStep % 2 == 0)
				fruityDancer.animation.play(fruityDances[fruitySave.data.curDance] + 'Right', false);
		}
	}

	function onBeatHit(event:SongTimeScriptEvent) {
		super.onBeatHit(event);
		var state = PlayState.instance;
		if (state == null) return;
		
		if (!holdingDancer) {
			if (event.beat % 2 == 1)
				fruityDancer.animation.play(fruityDances[fruitySave.data.curDance] + 'Left', false);
			else if (event.beat % 2 == 0)
				fruityDancer.animation.play(fruityDances[fruitySave.data.curDance] + 'Right', false);
		}
	}
	
	function onSubStateOpenBegin(event:SubStateScriptEvent) {
		super.onSubStateOpenBegin(event);
		var state = PlayState.instance;
		if (state == null) return;
		
		if (Std.isOfType(event.targetState, StickerSubState)) { FlxG.mouse.visible = false; }
	}

	function onSongEnd(event) {
		super.onSongEnd(event);
		FlxG.mouse.visible = false;
	}
}